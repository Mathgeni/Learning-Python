asyncio.Lock() - механизм, обеспечивающий монопольный доступ к общему ресурсу. Используется для предотвращения
 одновременного доступа к общему ресурсу из нескольких корутин.

asyncio.Event() - объект, позволяющий организовать доступ к ресурсу на основе заданных событий. Это примитив
 синхронизации, который позволяет одной корутине сигнализировать другим о том, что произошло какое-то событие.
  Корутины, которые ожидают события, будут приостановлены до тех пор, пока событие не будет установлено.

syncio.Condition() - комбинирует функциональность Lock() и Event(). Это объект условия, который позволяет задачам
 ожидать определенного состояния или сигнала, чтобы продолжить выполнение. Условие может быть связано с определенным
  Lock() и задачи могут ожидать его установки и освобождения. Это более сложный примитив синхронизации, который можно
   использовать для координации работы между несколькими корутинами. Он позволяет одной корутине ждать, пока другая
    корутина не установит определенное условие.

asyncio.Semaphore() - семафорный объект, который управляет внутренним счетчиком. Он позволяет ограничить доступ к
 общему ресурсу заданному количеству задач. Задачи могут запрашивать доступ к ресурсу, и если счетчик не превышает
  заданное значение, доступ будет предоставлен, и счетчик будет увеличен.

asyncio.BoundedSemaphore() - ограниченная версия семафора. Он ограничивает внутренний счетчик, чтобы не превышал
 заданное значение. Все остальное функциональность аналогична Semaphore().

asyncio.Barrier() - это простой примитив синхронизации, позволяющий блокировать выполнение до тех пор, пока на
 нем не будет ожидать определенное количество задач. Задачи могут ожидать метод wait() и будут блокироваться до
  тех пор, пока указанное количество задач не закончит ожидать wait(). В этот момент все ожидающие задачи одновременно
   разблокируются. В качестве альтернативы ожиданию в wait() может использоваться async with.

asyncio.Queue() - объект очереди, который обеспечивает безопасный и упорядоченный обмен данными между асинхронными
 задачами. Задачи могут помещать элементы в очередь и извлекать их в порядке, в котором они были помещены. Очередь
 также может быть ограничена по размеру, чтобы ограничить потребление ресурсов.
